\chapter{Software}

    \section{Funcionamiento del Sistema de Control}
    
        \subsection{Introducción}
        
            El sistema de control del proyecto es el encargado de administrar los periodos de carga y descarga de la batería, optimizando su uso en función de los datos recogidos en tiempo real por los distintos sensores que lo integran, distintos datos en formato analógico de la batería, que son sensados para luego ser digitalizados y enviados a la aplicación móvil del usuario.\par
            Esta etapa forma el núcleo lógico del sistema, protagonizada por una RP2040-Zero, ejerce como nexo entre los componentes analógicos y nuestra aplicación.\par
            El microcontrolador se encuentra programado en C, un lenguaje que gracias a su bajo nivel, podrá ser ejecutado por el microcontrolador a una velocidad adecuada.\par
            
        \subsection{Datos obtenidos}
        
            Esta placa cuenta con 2 tipos de sensor principales, que trabajando en conjunto entregan los datos del funcionamiento en tiempo real de la batería y del sistema, información suficiente para continuar con su control.\par
            
            \subsubsection{Encoder Rotativo Incremental}
            
                Encargado de brindarle información al sistema sobre la posición y la velocidad angular, datos que utilizará el sistema para calcular la cantidad de vueltas y la dirección en la que rota el motor. Posee una gran precisión en sus respuestas por la cantidad de pulsos que envía por revolución. Nos permite calcular el porcentaje de carga de la batería, mientras nos brinda los datos para prevenir el funcionamiento errático del sistema.\par
                Para más información sobre este componente en concreto revisar el Apéndice C, y más específicamente la Figura \ref{encoder}.\par

                \subsubsubsection{Funcionamiento del Encoder}
                \label{fde}
                
                    El encoder basa su funcionamiento en dos señales digitales A y B, estas son generadas en cada pulso y están desfasadas 90° entre sí. Cuando el encoder está alimentado, comienza a enviar pulsos, mismos que variarán cuando el motor esté en movimiento. Para decodificar esta sucesión de pulsos, utilizamos la lectura en cuadratura. Este método basa su funcionamiento en la detección de cambios o transiciones entre las señales A y B.\par
                    Analizando dicha sucesión, este sistema busca detectar el momento en el que se complete un \textbf{ciclo} o \textbf{vuelta}, una sucesión de 4 estados en los que:\par
                    
                    \begin{itemize} [label=•]
                        \setlength{\itemindent}{1.5em}
                        
                        \item A sube (0 a 1)
                        \item B sube (0 a 1)
                        \item A sube (1 a 0)
                        \item B sube (1 a 0)
                    \end{itemize}
                    
                    Es importante observar que hacemos énfasis en el estado anterior de cada señal, ya que lo que realmente nos interesa es la transición entre un estado y otro.\par
                    Nuestro sistema utiliza un contador \texttt{\textbf{counter}} para llevar registro de las transiciones que efectúan las señales del encoder, este se incrementa a medida que se presentan las variaciones que nos interesan. A continuación, presento una serie de estados en los que observaremos el ciclo mencionado anteriormente y el uso del contador en él\par

                    \begin{table}[H]
                        \centering
                        \begin{tabular}{|c|c|c|c|c|c|c|}
                            \hline
                             N° & Estado Anterior A & Estado Anterior B & Estado Actual A & Estado Actual B & Acción & Contador\\
                             \hline
                             1 & 0 & 0 & 0 & 0 & - & -\\
                             \hline
                             2 & 0 & 0 & 1 & 0 & A sube & +1 (\texttt{\textbf{counter}})\\
                             \hline
                             3 & 1 & 0 & 1 & 0 & - & -\\
                             \hline
                             4 & 1 & 0 & 1 & 1 & B sube & -\\
                             \hline
                             5 & 1 & 1 & 0 & 1 & A baja & -1 (\texttt{\textbf{counter}})\\
                             \hline
                             6 & 0 & 1 & 0 & 0 & B baja & -\\
                             \hline
                        \end{tabular}
                        \caption{Tabla de Verdad para Encoder Rotativo en Cuadratura}
                        \label{tab:s1}
                        \end{table}
                        
                        Observamos que:\par
                        \begin{itemize} [label=•]
                            \setlength{\itemindent}{1.5em}
                            
                            \item Cuando ambos pulsos son iguales, no hay cambios en el \texttt{counter} (Estados 1 y 3).
                            \item El incremento del \texttt{counter} (\texttt{counter ++}) ocurre cuando A aumenta y A se mantiene (Estado 2).
                            \item La reducción del \texttt{counter} (\texttt{counter --}) ocurre cuando B aumenta y A se mantiene (Estado 4)
                            \item  Cuando cualquiera de las variables baja a 0 mientras la otra se mantiene, no hay cambios en el \texttt{counter} (Estados 5 y 6).
                        \end{itemize}
                        
                    El incremento en el counter implica giro en sentido horario, su reducción será giro en sentido antihorario.\par
                    Teniendo en cuenta la cantidad de pulsos que emite nuestro encoder por cada revolución, podremos\par

                \subsubsubsection{Datos obtenidos por el Encoder}
                    El encoder de nuestro sistema se encuentra conectado al eje del motor generador que mueve la carga de la batería. El encoder nos brinda información angular sobre la posición del eje del motor y las vueltas que realizó.\par
                    Conociendo la cantidad de vueltas que equivalen a un recorrido completo de la batería, podremos conocer el punto al que se encuentra el peso durante todo su funcionamiento.\par
                    Principalmente, buscamos evitar dos situaciones:\par
                    
                    \begin{itemize} [label=•]
                \setlength{\itemindent}{1.5em}
                        \item Si el peso se encuentra muy cerca del límite inferior, \textbf{NO} podrá descargarse la batería.
                        \item Si el peso está muy cerca del límite superior, el mismo \textbf{NO} podrá seguir subiendo con la carga de la batería.\par
                    \end{itemize}
                    
                    Estos factores son cruciales porque impiden un posible fallo mecánico de la batería, uno que podría derivar en fuertes daños al dispositivo, sus alrededores y seres circundantes.\par
                    Aparte de los riesgos potenciales que podemos prevenir, nos encontramos en la necesidad de controlar la carga y descarga de la batería, conocer el porcentaje de carga en el que se encuentra y asegurarnos de brindarle esta información al usuario. Con los datos que nos brinda el encoder podemos calcular el porcentaje de carga de la batería; ya que:\par
                    \begin{equation}
                        Porcentaje_{Carga} = \frac{\texttt{lap\_counter}}{\texttt{complete\_laps}} \times 100
                    \end{equation}
                    
                    Donde:\par
                    \begin{itemize} [label=•]
                \setlength{\itemindent}{1.5em}
                
                        \item \texttt{complete\_laps} es la cantidad de vueltas que necesita la batería para completar el recorrido.
                        \item \texttt{lap\_counter} es la cantidad de vueltas que realizó el motor, se actualiza constantemente, cuando realiza vueltas en sentido horario el contador aumenta, y cuando las realiza en sentido antihorario decrece.
                    \end{itemize}
                    
            \subsubsection{INA219}
                El sistema cuenta con 4 sensores INA219. Cada sensor se encuentra midiendo distintos parámetros, con la finalidad de asegurarle al sistema de control valores actualizados de corriente y tensión; de esta forma, el sistema podrá informar al usuario sobre sus acciones a nivel energético, mientras administra la carga y descarga de la batería de forma óptima en tiempo real.\par
                Para más información sobre este componente en concreto revisar el Apéndice C, y más específicamente la Figura \ref{ina219}.\par

                \subsubsubsection{Funcionamiento del INA219}
                    Estos sensores tienen un principio de funcionamiento muy simple, cuentan con una resistencia de shunt (una resistencia cuyo valor es muy bajo) conectada en serie a la carga.\par
                    El circuito obtiene la diferencia de potencial eléctrico entre sus terminales V+ y V- (donde se encuentra conectada la carga) y conoce el valor de la fuente de alimentación del circuito, por lo tanto podrá obtener el valor de la V de shunt.\par
                    
                        \begin{equation}
                            V_{Shunt} = V_{Total} - V_{Carga}
                        \end{equation}

                    El valor de la tensión de Shunt será muy bajo (suele ser menor a 50mV). El sensor lo que busca es obtener este valor para, utilizando la Ley de Ohm, obtener el valor de corriente.\par

                    \begin{equation}
                        I_{Shunt} = \frac{V_{Shunt}}{R_{Shunt}}
                    \end{equation}

                    Para hacer este cálculo, el valor de Vshunt tiene que estar en formato digital, por este motivo el módulo INA219 tiene su propio ADC integrado. Dentro de las configuraciones que solicitan los módulos encontramos los rangos de revolución del ADC interno. De acuerdo a la cantidad de bits que solicitemos, tendremos mayor o menor precisión en los resultados de las medidas; mientras más bits tendremos más precisión, pero también tomará más tiempo el proceso.\par

                    \begin{table}[H]
                        \centering
                        \begin{tabular}{|c|c|}
                        \hline
                            Resolución (bits) & Tiempo de Conversión\\
                        \hline
                             9 bits & 84 $\mu s$ \\
                        \hline
                            10 bits & 148 $\mu s$\\
                        \hline
                            11 bits & 276 $\mu s$\\
                        \hline
                            12 bits & 532 $\mu s$\\
                        \hline
                        \end{tabular}
                        \caption{Tabla de resolución del ADC}
                        \label{tab:s2}
                    \end{table}

                    Una señal tan pequeña (menor a 50mV) contará con muy poco porcentaje de resolución efectiva. La solución que nos propone el mismo módulo es amplificar la señal, dentro de los parámetros de configuración nos encontramos con 4 opciones de ganancia para la $V_{Shunt}$:\par

                    \begin{table}[H]
                        \centering
                        \begin{tabular}{|c|c|}
                        \hline
                            Ganancia & Máximo $V_{Shunt}$ medible\\
                        \hline
                             1x & ±320 mV \\
                        \hline
                            2x & ±160 mV\\
                        \hline
                            4x & ±80 mV\\
                        \hline
                            8x & ±40mV\\
                        \hline
                        \end{tabular}
                        \caption{Tabla de Ganancias}
                        \label{tab:s3}
                    \end{table}
                    
                    Cada valor de ganancia tiene un amplificador asociado, cada uno cuenta con sus propias características, su valor de ganancia y un valor máximo absoluto. Es importante asegurarnos de no exceder dicho valor porque causaría una saturación en la salida del amplificador, resultando en una pérdida de datos y una lectura incorrecta.\par
                    Una vez calculado el valor de corriente de shunt, podremos suponer que este es el mismo que circula por el resto de la rama, incluyendo a la carga.\par

                    \begin{equation}
                        I_{Shunt} = I_{Carga}
                    \end{equation}
                    
                    El valor de corriente se encuentra en formato digital y listo para ser enviado.\par
                    El módulo de INA219 cuenta con un puerto de comunicación i2c. Estos sensores permiten el uso en simultáneo de hasta 16 dispositivos INA219 conectados en el mismo puerto i2c. Dicha función es posible porque los datos enviados se encuentran encabezados por un byte de dirección, dato que se puede configurar desde los pines A1 y A0 de los módulos. Al conectar estos pines a distintos puntos, podremos obtener distintas direcciones, a continuación podemos observar las distintas posibilidades que nos ofrece.\par

                    \begin{table}[H]
                        \centering
                        \begin{tabular}{|c|c|c|}
                        \hline
                            \texttt{A1} & \texttt{A0} & \texttt{SLAVE ADDRESS}\\
                        \hline
                             \texttt{GND} & \texttt{GND} & \texttt{1000000}\\
                        \hline
                            \texttt{GND} & \texttt{Vs+} & \texttt{1000001}\\
                        \hline
                            \texttt{GND} & \texttt{SDA} & \texttt{1000010}\\
                        \hline
                            \texttt{GND} & \texttt{SLC} & \texttt{1000011}\\
                        \hline
                            \texttt{Vs+} & \texttt{GND} & \texttt{1000100}\\
                        \hline
                            \texttt{Vs+} & \texttt{Vs+} & \texttt{1000101}\\
                        \hline
                            \texttt{Vs+} & \texttt{SDA} & \texttt{1000110}\\
                        \hline
                            \texttt{Vs+} & \texttt{SLC} & \texttt{1000111}\\
                        \hline
                            \texttt{SDA} & \texttt{GND} & \texttt{1001000}\\
                        \hline
                            \texttt{SDA} & \texttt{Vs+} & \texttt{1001001}\\
                        \hline
                            \texttt{SDA} & \texttt{SDA} & \texttt{1001010}\\
                        \hline
                            \texttt{SDA} & \texttt{SLC} & \texttt{1001011}\\
                        \hline
                            \texttt{SLC} & \texttt{GND} & \texttt{1001100}\\
                        \hline
                            \texttt{SLC} & \texttt{Vs+} & \texttt{1001101}\\
                        \hline
                            \texttt{SLC} & \texttt{SDA} & \texttt{1001110}\\
                        \hline
                            \texttt{SLC} & \texttt{SLC} & \texttt{1001111}\\
                        \hline
                        \end{tabular}
                        \caption{Tabla I2C}
                        \label{tab:s4}
                    \end{table}
                    Para nuestro sistema, solo necesitamos 4 dispositivos, por lo tanto 4 direcciones.\par
                    \begin{table}[H]
                        \centering
                        \begin{tabular}{|c|c|c|c|}
                        \hline
                            \texttt{A1} & \texttt{A0} & \texttt{SLAVE ADDRESS} & \texttt{HEXADECIMAL VALUE}\\
                        \hline
                             \texttt{GND} & \texttt{GND} & \texttt{1000000} & \texttt{0x40}\\
                        \hline
                            \texttt{GND} & \texttt{Vs+} & \texttt{1000001} & \texttt{0x41}\\
                        \hline
                            \texttt{Vs+} & \texttt{GND} & \texttt{1000100} & \texttt{0x44}\\
                        \hline
                            \texttt{Vs+} & \texttt{Vs+} & \texttt{1000101} & \texttt{0x45}\\
                        \hline
                        \end{tabular}
                        \caption{Valores que usamos}
                        \label{tab:s5}
                    \end{table}
                    
                    Para configurar los registros de dirección de los módulos, estos cuentan con los pines A1 y A0. Por practicidad, cada uno tiene un pin que lo acompaña y que nos facilita su conexión con el pin de Vs+. Nos permite realizar un puente entre ambos pines (el pin An queda conectado a Vs+) o dejarlo como se encuentra de fábrica, sin ninguna conexión (el valor que toma An será el de GND). El módulo ofrece más configuraciones que implican la conexión de A1 y A0 con otros puertos, pero para mantener las conexiones simples decidimos obviarlos.\par
                    
                \subsubsubsection{Datos obtenidos por el INA219}
                    Como mencionamos previamente, contamos con 4 módulos medidores de corriente, cada uno conectado a un punto distinto de nuestro sistema para realizar las mediciones correspondientes. Los sensores están destinados a:\par

                \begin{itemize} [label=•]
                    \setlength{\itemindent}{1.5em}
                    
                    \item Consumo del usuario.
                    \item Entrega del módulo MPPT.
                    \item Consumo del motor de la batería durante la carga.
                    \item Entrega del panel solar, previo al módulo MPPT.
                \end{itemize}
                
                Cada sensor requiere una dirección para poder utilizar el puerto I2C, respectivamente:\par

                \begin{itemize} [label=•]
                    \setlength{\itemindent}{1.5em}
                    
                    \item \texttt{0x40}
                    \item \texttt{0x41}
                    \item \texttt{0x44}
                    \item \texttt{0x45}
                \end{itemize}
                
                En función de los datos obtenidos, el sistema los procesará. A continuación una breve descripción de la utilidad que nos dará cada uno:\par

                \begin{itemize} [label=•]
                    \setlength{\itemindent}{1.5em}
                    
                    \item \texttt{0x40} Consumo del usuario: A través de esta lectura, conocemos el consumo actual del usuario. Nos permite manejar la carga y descarga de la batería en tiempo real al compararlo con la entrega de energía del MPPT.
                    \item \texttt{0x41} Entrega del módulo MPPT: Esta será la energía que luego tendrá disponible el consumidor, por eso es crucial el dato para saber si la energía obtenida es suficiente o no para su uso.
                \end{itemize}
                
                Estos últimos dos datos son recolectados con una alta prioridad en el programa que controla al sistema, ya que son cruciales para el funcionamiento de la batería en sí.\par
                
                \begin{itemize} [label=•]
                    \setlength{\itemindent}{1.5em}
        
                    \item \texttt{0x44} Consumo del motor de la batería durante la carga: El consumo de la batería es equivalente al monto de energía que nuestra batería “guarda”. Nos parece importante que quien utiliza el sistema sea consciente de su consumo y la eficiencia de su producto.
                    \item \texttt{0x45} Entrega del panel solar, previo al módulo MPPT: Este dato nos otorga información sobre el funcionamiento del panel solar, que luego será modificada por el MPPT. Combinando estos dos datos, podremos brindarle al usuario datos sobre su obtención de energía.
                \end{itemize}
                
        \subsection{Funcionamiento de la Batería}
            Una vez obtenidos los datos, el microcontrolador puede comenzar a administrar la carga y descarga de la batería. El sistema contempla distintos escenarios posibles para decidir su próxima acción, optando entre:\par
            
            \begin{itemize} [label=•]
                \setlength{\itemindent}{1.5em}
                
                \item Si la corriente que entrega el panel solar es suficiente, entrega energía directa desde el panel solar (mientras considera un posible excedente en dicha entrega, evalúa la posibilidad de aprovecharlo para cargar la batería).
                \item Si la corriente no es suficiente, decide descargar la batería.
            \end{itemize}
            
            Previo a cada movimiento que desee realizar el sistema sobre la batería, utiliza los datos recolectados por el encoder para chequear el porcentaje de carga a la que se encuentra, bloqueando el movimiento si:\par
            
            \begin{itemize} [label=•]
                \setlength{\itemindent}{1.5em}
                
                \item La carga es menor al 20\%, la batería no se seguirá descargando.
                \item La carga es mayor al 80\%, no seguirá cargándose.
            \end{itemize}
            
            Por otro lado, si la corriente entregada por el panel solar no supera en exceso el valor de corriente que necesita el motor para cargar el peso, no se le dará inicio a la carga de la batería. Esto se debe a que cada vez que el motor es encendido, consume un pico de corriente inicial, un valor que supera de forma significativa al consumo de corriente nominal del mismo. Para evitar este exceso de consumo de forma repetitiva o continua evitamos el inicio de la carga cuando el excedente de energía es bajo.\par
        \section{Códigos de la etapa de control}
        
            \subsection{Introduccción}
                La etapa de control, conformada por una RP2040-Zero, es manejada por un código principal main.c, este utiliza en su totalidad las funciones desarrolladas en la librería \textcolor{dark_violet}{\textbf{GraviCap}}.\par
                El microcontrolador que elegimos tiene disponibilidad de dos núcleos. Para este sistema decidimos aprovechar ambos. Uno de los núcleos trabaja con FreeRTOS, un sistema de respuesta en tiempo real que ordena las funciones que realiza el programa en forma de “tareas”, asignándoles distintas prioridades a cada una para intercalar la ejecución de todas ellas de forma óptima.\par
                Para más información sobre este componente en concreto revisar el Apéndice C, y más específicamente la Figura \ref{rp2040}\par
            
            \subsection{Librería \textcolor{dark_violet}{\textbf{GraviCap}}}
                Para este sistema creamos la librería gravicap, está conformada por los archivos gravi.c y gravi.h. Entre ambos códigos declaran y desarrollan la totalidad de las funciones que derivan en el funcionamiento del sistema.\par
                En el archivo gravi.h creamos una estructura mediciones\_ina219.\par
                \lstinputlisting[language=C, firstline=19, lastline=27]{gravi.h}\par
                Esta contiene el nombre de cada sensor INA219, sus datos de configuración y variables que almacenan los datos medidos por ellos.\par
                En gravi.h podemos encontrar rambién declaradas las funciones antes mencionadas, desarrolladas luego en el archivo gravi.c:\par
                
                \subsubsection{void task\_init(void *params)}
                    Esta función contiene todas las inicializaciones de los distintos puertos (UART, I2C y GPIO), configura el funcionamiento de cada sensor INA219 y declara las \textit{queues} que serán utilizadas posteriormente. Al tratarse de la primera función que ejecuta el programa, para asegurar que el motor esté frenado al principio (que no cargue ni descargue la batería antes de realizar cualquier tipo de consulta sobre el estado de la carga), por eso luego de iniciar y configurar todo aquello que requerirá el programa, ejecuta la función de stop(), desarrollada posteriormente.\par

                \subsubsubsection{void status()}
                    Esta función es la que llamamos antes de ordenar cualquier movimiento en la batería para consultar si es posible realizarlo. Esta espera que el \texttt{core\_1} envíe el valor de \texttt{carga} para poder realizar su función. Una vez recibido, considera el porcentaje de carga y el valor mínimo crítico (\texttt{min\_critico}), un valor de porcentaje destinado a acotar superior e inferiormente el intervalo por el que se desplaza el peso de la batería, de esta forma, evitamos que se desplace por los extremos, donde podría suceder que:\par
                    \begin{enumerate}
                    \setlength{\itemindent}{1.5em}
                    
                        \item Se desperdicie energía al solicitar una carga (el consumo de un pico de arranque del motor) por un intervalo bajo de carga.
                        \item Un fallo mecánico del dispositivo al seguir forzando el movimiento (carga o descarga) en el límite del intervalo existente.
                    \end{enumerate}
                    La función trabaja con las variables \texttt{test\_up} (habilitará la carga de la batería) y \texttt{test\_down} (habilitará la descarga de la batería), ambas variables del tipo bool (únicamente valdrán 0 o 1). La función prevee 3 situaciones posibles:\par
                    \begin{enumerate}
                    \setlength{\itemindent}{1.5em}
                    
                        \item La carga se encuentra cerca del límite inferior, entonces no puede bajar más pero sí puede subir (\texttt{test\_up = 0} y \texttt{test\_down = 1})\par
                        \lstinputlisting[language=C, firstline=310, lastline=310]{gravi.c}
                        \item La carga se encuentra cerca del límite superior, entonces no puede subir más, pero sí bajar (\texttt{test\_up = 1} y \texttt{test\_down = 0})\par
                        \lstinputlisting[language=C, firstline=320, lastline=320]{gravi.c}
                        \item La carga se encuentra dentro del rango intermedio donde ambas opciones son viables (\texttt{test\_up = 0} y \texttt{test\_down = 0})\par
                        \lstinputlisting[language=C, firstline=315, lastline=315]{gravi.c}
                    \end{enumerate}
                    Observamos que, cuando las variables se encuentran en 0 dan dejan constancia de que es seguro realizar dicho movimiento, cuando están en 1 lo impedirán.\par
                    Si se presentara un error extraordinario donde la función no puede ingresar en ninguno de las condiciones (if) de la función, la excepción (else) les da valor 1 a las dos variables, impidiendo cualquier movimiento posible hasta corregir el error.\par

                \subsubsection{Funciones de lectura de sensores INA219}
                    Estas 4 funciones son las que recogen los datos de cada uno de los sensores, para luego almacenarlos en sus variables correspondientes, dejándolos a disposición para su uso en el resto de las funciones.\par
                    \begin{itemize} [label=•]
                        \setlength{\itemindent}{1.5em}
                        
                        \item \texttt{void task\_lectura\_sensor\_ina219\_0x40()}
                        \item \texttt{void task\_lectura\_sensor\_ina219\_0x41()}
                        \item \texttt{void task\_lectura\_sensor\_ina219\_0x44()}
                        \item \texttt{void task\_lectura\_sensor\_ina219\_0x45()}
                    \end{itemize}
                
                \subsubsection{void task\_consulta\_all(void *params)}
                    Esta función es la principal encargada de activar la carga y la descarga de la batería según la solicitud del usuario y la entrega de energía del MPPT. Para tomar esta decisión, utiliza los valores de las variables de “test” (\texttt{test\_up} y \texttt{test\_down}, mismas que modifica la función status()).\par
                    Para analizar la situación en la que se encuentra el sistema en general, depende totalmente de dos datos:\par
                    
                    \begin{itemize} [label=•]
                        \setlength{\itemindent}{1.5em}
                        
                        \item La medición de corriente del Ina219 0x40 aquel que recoge los datos de consumo del usuario
                        \item La medición de corriente del módulo Ina219 0x41, el que recoge los datos de entrega del MPPT
                    \end{itemize}
                    
                    La función inicia solicitando los datos de una \texttt{queue} o cola \texttt{queue\_ina219\_consulta\_all} que incluye los dos valores antes mencionados.\par
                    \lstinputlisting[language=C, firstline=233, lastline=233]{gravi.c}\par
                    Luego llama a la función \texttt{status()}. Esta esperará la llegada del valor de \texttt{carga} para actualizar los valores de las variables de testeo \texttt{test\_up} y \texttt{test\_down}.\par
                    Una vez actualizados, la función plantea 2 posibles escenarios al considerar los valores de corriente del consumidor (Ina219 0x40) y la entrega del MPPT (Ina219 0x41).\par
                    \begin{enumerate}
                    \setlength{\itemindent}{1.5em}
                    
                        \item Si el consumidor está solicitando más de lo que entrega el MPPT\par
                        \lstinputlisting[language=C, firstline=320, lastline=320]{gravi.c}
                        En este caso, el programa considera el valor de \texttt{test\_down}, valor que indicará si la batería tiene la carga suficiente como para ser descargada entregando energía almacenada al usuario.
                        Si este valor fuera positivo (\texttt{test\_down = 0})es posible descargar la bateŕía para obtener la energía almacenada, el sistema lo hará.\par
                        Si el valor fuera negativo (\texttt{test\_down = 1}) no es posible efectuar la descarga, entonces el sistema dependerá de la energía de la red eléctrica.\par
                        \item Si el consumidor está solicitando menos de los que entrega el MPPT\par
                        \lstinputlisting[language=C, firstline=320, lastline=320]{gravi.c}
                        En este caso la variable a considerar será la de \texttt{test\_up}, ya que, luego de asegurarnos de que el consumo de nuestro usuario está cubierto al 100\% por la energía entregada por el MPPT, evaluamos la posibilidad de que haya un sobrante de energía que pueda ser aprovechado en la posteridad por el usuario.\par
                        Dicha evaluación considera 2 opciones:\par
                        \begin{enumerate}
                        \setlength{\itemindent}{1.5em}
                        
                            \item La cantidad de energía generada es igual a la consumida, o el sobrante es muy bajo para ser utilizado en una carga de la batería\par
                            \lstinputlisting[language=C, firstline=320, lastline=320]{gravi.c}
                            En este caso el consumidor queda consumiendo 100\% de energía renovable, mientras la batería permanece estática.\par
                            \item La cantidad de energía generada es mucho mayor a la consumida, por lo tanto hay un sobrante energético.\par
                            \lstinputlisting[language=C, firstline=320, lastline=320]{gravi.c}
                            El consumidor estará consumiendo toda la energía que solicite desde la salida del módulo MPPT, mientras la batería es cargada con el sobrante de energía. Dicho sobrante será aprovechado luego.\par

                        \end{enumerate}
                    \end{enumerate}

                \subsubsection{void core\_1\_task()}
                    Al utilizar el segundo núcleo del microcontrolador (\texttt{core\_1}), requerimos declarar una función que contenga las funciones que realizará el mismo. En nuestro caso, el \texttt{core\_1} centra sus funciones en la lectura del Encoder. Este envía pulsos constantemente, mismos que hay que leer sin pausa alguna para asegurar la recepción efectiva de cada uno de sus estados. Si perdiéramos alguno de ellos, podría volverse erróneo el resultado causando algún fallo o defecto en el funcionamiento del dispositivo.
                    Como explicamos en el apartado \ref{fde}, la lectura de los datos del encoder depende de los datos que envían permanentemente dos pines, dos señales seriales desfasadas 90°. La función considera los valores actuales y anteriores de ambas variables, detecta las transiciones y los ciclos durante las distintas lecturas. Cuenta con una variable \texttt{counter} que almacena las transiciones y luego la considera para obtener el \texttt{lap\_counter}, la variable que almacena la cantidad de vueltas.\par
                    La función consta de un bucle infinito\par
                    
                    \lstinputlisting[language=C, firstline=267, lastline=267]{gravi.c}
                    
                    De esta forma aseguramos que la lectura sea constante. El motivo por el que decidimos usar el modo \texttt{multicore}, fue permitir, justamente, este bucle infinito. Si la recolección de datos del encoder fuera ejecutada por el mismo núcleo que contiene el resto de las funciones, podría ocurrir dos escenarios:\par
                    \begin{enumerate}
                    \setlength{\itemindent}{1.5em}
                    
                        \item El resto de las tareas nunca ocurrirían, porque el núcleo está constantemente ocupado recolectando pulsos del encoder.
                        \item La lectura del encoder es leída con huecos, volviéndose completamente errónea e inutilizable.
                    \end{enumerate}
                    
                    El intercambio de datos entre ambos núcleos es posible gracias a la función\par
                    \texttt{void multicore\_fifo\_push\_blocking(uint32\_t data);}\par
                    Esta función envía un entero de 32 bits sin signo desde un núcleo al otro por medio de la FIFO (First In, First Out) interna del RP2040.\par
                    Observamos este intercambio de datos en dos situaciones:\par

                    \begin{enumerate}
                    \setlength{\itemindent}{1.5em}
                    
                        \item Cuando el porcentaje de carga varió hasta un 15\% desde su última actualización en el core\_1\par
                        \lstinputlisting[language=C, firstline=287, lastline=287]{gravi.c}\par
                        \item Cada vez que es llamada la función de status(); contiene una cola que espera el valor de \texttt{carga}//monoespaciado// para configurar los datos de test con variables actualizadas en la inmediatez\par
                    \end{enumerate}

                \subsubsection{void carga\_motor()}
                    Esta función es la que llamamos cada vez que queremos iniciar la carga de la batería. Durante el funcionamiento del sistema, el motor varía entre 3 estados:\par
                    \begin{enumerate}
                        \setlength{\itemindent}{1.5em}
                        \item Carga
                        \item Descarga
                        \item Frenado (\textit{stop})
                    \end{enumerate}

                    Previo al inicio de la carga, debemos corroborar que el motor no se encuentre en alguno de los dos estados restantes, descarga o frenado. A través de una serie de consultas sobre el estado previo de los relés encargados de iniciar cada movimiento, podemos reconocer en qué estado se encuentran previamente, dato que consideraremos para acomodar las configuraciones del otro relé, y los leds asociados a cada estado.\par

            \subsubsection{void motor\_stop()}
                Para evitar una descarga inminente, si es que el motor no se encuentra alimentado para realizar una carga, debemos conectar sus dos terminales entre sí, frenando el motor de forma inmediata. Para que efectuar esta conexión, ambos relés deben estar encendidos.\par

            \subsubsection{int descarga\_motor()}
                Al realizar la descarga del motor, no podemos simplemente alimentarlo de forma inversa porque de esta forma no estaríamos cumpliendo con la premisa principal de “hacer uso de la energía potencial gravitatoria almacenada”, simplemente estaríamos moviendo una carga sin sentido.\par
                Para evitar que esto suceda, durante una descarga habitual encendemos el motor en sentido inverso por un lapso de tiempo muy reducido, venciendo la fricción estática inicial de la carga mientras comienza a moverse.\par
                Teóricamente, el movimiento sostenido en el tiempo por la inercia que genera el peso de la carga, debería ser suficiente para evitar pausas en la descarga, pero esto puede fallar por pequeñas variaciones en el entorno que modifiquen el funcionamiento de la batería, podría tratarse de cambios en la temperatura, en la tensión de los cables de la batería, la densidad del aire, la flexión de los materiales u otros, presentándose pausas sin antes haber activado la pausa o la carga del motor.\par
                Si la descarga se detiene por cualquiera de estos factores, nuevamente le daremos un pulso al motor en sentido inverso para volver a tratar de vencer la fricción estática, acción que se repetirá hasta que acabe la solicitud de descarga por parte del sistema.\par
                Esta función es la encargada de mantener este estado de descarga venciendo las adversidades que pudieran presentarse en el entorno.\par

            \subsubsection{void actualizar\_leds(float porcentaje\_carga)}
                Para mantener el grado de carga de la batería explícito en un tablero que la acompaña, agregamos una serie de leds que representan un “cargador”, variando la cantidad que se encenderán a cada instante según el valor más reciente obtenido de la carga (cada led del tablero tiene distintos colores en función de la carga que representan, variando entre azul y rojo, para mantener la estética y practicidad en la lectura de este tablero).\par
                En un principio, la función solicita el valor de \texttt{porcentaje\_carga} (variable del tipo float), el mismo le será entregado como parámetro con el valor de carga actualizado. Esta función tiene como objetivo ser llamada durante la ejecución de \texttt{status()}, misma función que nos asegura el valor reciente de carga al solicitarlo al \texttt{core\_1} en sus primeras líneas.\par
                Considerando que \texttt{actualizar\_leds} se encuentra llamada en \texttt{status()}, misma función utilizada en \texttt{task\_consulta\_all}, aseguramos que la actualización de los leds se ejecute con la misma frecuencia que esta última tarea, una que cuenta con prioridad 3, valor que nos asegura que se repetirá con mucha frecuencia mientras funcione el sistema.\par

                \subsubsection{void prepare\_char\_uart(char *ubicacion, mediciones\_ina219 *medicion, size\_t ubicacion\_size, float porcentaje\_carga)}
                    Para enviar los distintos datos recolectados por los sensores al usuario, es necesario incluirlos a todos ellos en distintas cadenas de texto listas para ser transportadas por el puerto serial. Esta función es la encargada de crearlas.\par
                    Para realizar esta conversión, utiliza la función de C \texttt{snprint}, esta formatea cadenas de texto y las almacena en una cadena preexistente.\par
                    Sintaxis de la función: \texttt{int snprintf(char *buffer, size\_t buf\_size, const char *format, ...);}
                    Al principio del programa fueron declaradas 4, destinadas a contener los valores medidos de cada INA219.\par

                    \lstinputlisting[language=C, firstline=38, lastline=41]{gravi.c}\par
                    
                    El tamaño de cada una está especificado en:\par

                    \lstinputlisting[language=C, firstline=19, lastline=19]{gravi.c}\par
                    
                    De esta forma se encuentra con fácil acceso para ser modificado siempre que se requiera. Consideramos que las 4 cadenas tendrán tamaños iguales, todas contendrán el mismo tipo de dato.\par
                    La función solicita 4 parámetros:\par
                    \begin{enumerate}
                    \setlength{\itemindent}{1.5em}
                        
                        \item \texttt{char *ubicacion}: Refiere a la cadena donde se escribirán los datos luego especificados. Utilizamos las 4 cadenas mencionadas previamente.
                        \item \texttt{mediciones\_ina219 *medicion}: Se trata de la variable del tipo \texttt{mediciones\_ina219}, contenida localmente en una variable llamada \texttt{medicion}.
                        \item \texttt{size\_t ubicacion\_size}: Es el tamaño que tendrá la cadena en la que se almacena el resultado de esta operación. En nuestro caso, todas las cadenas tienen el tamaño previamente definido como \texttt{CHAR\_UART}.
                        \item \texttt{float porcentaje\_carga}: Es la variable definida localmente como \texttt{porcentaje\_carga}, pero la utilizamos para solicitar el valor de \texttt{carga}
                    \end{enumerate}
                    
                    Utilizando estos datos, la función genera una cadena del tipo JSON.\par

                    \lstinputlisting[language=C, firstline=330, lastline=330]{gravi.c}\par
                    
                    Donde podemos apreciar especificados los 5 valores destinados al servidor web.\par

                \subsubsection{void send\_uart()}
                    Esta función se encarga de preparar las cadenas de texto de cada sensor INA219, para hacerlo llama a la función \texttt{prepare\_char\_uart(char *ubicacion, mediciones\_ina219 *medicion, size\_t ubicacion\_size, float porcentaje\_carga)} cuatro veces (una por sensor), especificando entre sus parámetros los datos propios de cada sensor y sus cadenas asociadas.\par
                    Para efectuar estas tareas con los datos necesarios obtenidos y actuales, tiene una \texttt{queue queue\_ina219\_send\_uart }asociada.\par

                    \lstinputlisting[language=C, firstline=341, lastline=341]{gravi.c}\par                    
                    
                    Esta espera la recolección de los datos de los 4 sensores INA219, datos que se guardan en al \texttt{queue} al final de cada función de lectura de los mismos.\par
                    Luego de rellenar las 4 cadenas de texto, envía una por una por el puerto \texttt{UART1} utilizando la función \texttt{uart\_puts}\par
                    Sintaxis de la función: \texttt{void uart\_puts(uart\_inst\_t *uart, const char *s);}
                    
            \subsection{Programa Principal}
                \subsubsection{Introducción}
                    El programa principal, main.c, es el encargado de\par
                    El código principal trabaja delegando tareas a sus dos núcleos:\par
                \subsubsection{Uso de FreeRTOS}
                    Como mencionamos anteriormente, nuestro sistema requiere el manejo de datos y tareas en tiempo real, es por esto que optamos por la utilización del sistema \textbf{FreeRTOS}. Este requiere una sintaxis particular y un formato que difiere del utilizado habitualmente por los códigos \textbf{BareMetal}.\par
                    Su característica principal, es la utilización de tareas en la ejecución del programa, las mismas deben estar declaradas en el programa de ejecución principal o main.c. En su declaración, cada una solicita una serie de argumentos o parámetros especificados a continuación:\par

                    \lstinputlisting[lenguage=C]{adicional.c}
                    
                    Aquí un ejemplo de una de las tareas declaradas en este programa:\par
                    \lstinputlisting[language=C, firstline=67, lastline=73]{maino.c}\par

                    Uno de los parámetros que más vale la pena destacar es: \texttt{UBaseType\_t uxPriority}\par
                    En nuestro ejemplo:\par
                    \lstinputlisting[language=C, firstline=71, lastline=71]{maino.c}\par
                    Se trata del parámetro que le asigna distintas prioridades a las tareas.\par
                    Al utilizar FreeRTOS, no observamos el desarrollo de un programa habitual de BareMetal donde el código se ejecuta línea por línea hasta finalizar el archivo, en este caso ponemos en práctica el concepto de “Tarea” o \textit{Task}, conceptos propios de FreeRTOS.\par
                    Definición: Una tarea es “una serie de instrucciones que se ejecutará de acuerdo a su orden de prioridad hasta completarse, o hasta que presente una interrupción”.\par
                    \textbf{¿A qué nos referimos con esto?}\par

                    Nos interesa analizar dos conceptos centrales:\par
                    \begin{itemize} [label=•]
                        \setlength{\itemindent}{1.5em}
                        \item Orden de prioridad: Es uno de los parámetros que asignamos al momento de crear la tarea, como vimos previamente.\par
                        A la hora de ejecutar tareas, el programa empezará por aquellas que cuenten con la prioridad más alta, cuando abandone esta misma, irá por la siguiente con este mismo nivel de prioridad, si no lo hubiera baja un escalón y continúa por el siguiente nivel.\par
                        \item Interrupción: Con la finalidad de no perder tiempo en actividades vacías, el sistema de FreeRTOS nos permite realizar una interrupción en una tarea para reanudarla luego. Se ve así:\par
                        \lstinputlisting[language=C, firstline=170, lastline=170]{gravi.c}\par
                        En este caso, solicito una interrupción de 1000 Tiks, una medida de tiempo que configuré previamente.\par
                        La función de una tarea es ejecutada hasta que aparece la línea de interrupción; en este caso, el programa esperará 1000 tiks y volverá a reanudarla. Esto puede ser útil cuando la tarea solicita un dato o parámetro de otro dispositivo o similar, nos encontramos con “tiempo muerto” hasta que llegue la información. Para no desaprovecharlo, el código ejecuta otra tarea hasta que acaba el tiempo de Delay.\par
                        \end{itemize}
                    
                    Nuestro sistema basa su funcionamiento en 7 tareas.\par
                    Cada tarea tiene un nivel de prioridad designado, a continuación una tabla con el orden que les fue asignado.\par
                    
                        \begin{table}[H]
                            \centering
                            \begin{tabular}{|c|c|}
                            \hline
                                Tarea & Prioridad\\
                            \hline
                                task\_init & tskIDLE\_PRIORITY + 6UL (6) \\
                            \hline
                                task\_lectura\_sensor\_ina219\_0x40 & tskIDLE\_PRIORITY + 5UL (5)\\
                            \hline
                                task\_lectura\_sensor\_ina219\_0x41 & tskIDLE\_PRIORITY + 5UL (5)\\
                            \hline
                                task\_cons1ulta\_all & tskIDLE\_PRIORITY + 3UL (3) \\
                            \hline
                                1task\_lectura\_sensor\_ina219\_0x44 & tskIDLE\_PRIORITY + 2UL (2)\\
                            \hline
                                task\_lectura\_sensor\_ina219\_0x45 & tskIDLE\_PRIORITY + 2UL (2)\\
                            \hline
                                task\_send\_uart & tskIDLE\_PRIORITY + 1UL (1)\\
                            \hline
                            \end{tabular}
                            \caption{Tabla de Prioridades}
                            \label{tab:6}
                        \end{table}
                        
                    Mientras mayor sea el número de tskIDLE\_PRIORITY, mayor será la prioridad de la tarea.\par
                    En el caso de nuestro sistema, con 5 niveles de prioridad, dejando en primer lugar la función\par
                    \lstinputlisting[language=C, firstline=28, lastline=28]{maino.c}\par
                    
                    Es importante que esta función tenga la prioridad más alta para aseg1urar que se ejecute al principio del código sin excepciones, ya que contiene las distintas inicializaciones y configuraciones de pines, puertos y sensores. Esta tarea contiene una línea especial al final de la función, una que la elimina de la memoria luego de su finalización\par
                    \lstinputlisting[language=C, firstline=170, lastline=170]{gravi.c}\par
                    
                    De esta forma ahorramos memoria, sin sacrificar ningún dato de relevancia.\par
                    Podemos observar entre la designación de funciones listada en el archivo gravi.h, como aquellas que están destinadas a ser ejecutadas en una tarea, reciben un nombre encabezado por task\_ seguido de un título que hace referencia al uso que le daremos a esa función. Se trata de una convención utilizada en los nombres de las funciones de este estilo.\par
                    Revisando estas mismas tareas, esta vez en el archivo gravi.c donde se encuentran desarrolladas todas las funciones del programa, observamos como todas las tareas están compuestas por un bucle infinito (generalmente un \texttt{while(true)}). Esto se debe a que, por su naturaleza, las tareas no cuentan con principio o final, simplemente son listados de ejecuciones que deben repetirse de forma indefinida.\par
                    Para poder utilizar todas las funciones desde el archivo main.c sin la necesidad de declararlas allí, entre las primeras líneas de este archivo nos aseguramos de incluir los dos documentos que conforman la librería gravicap, donde previamente declaramos funciones y demás.\par
                    \lstinputlisting[language=C, firstline=2, lastline=3]{maino.c}\par
                
                \subsubsection{Uso del Multicore}
                    Los microcontroladores cuentan con uno o varios núcleos generalmente. Cada núcleo es una unidad de procesamiento independiente, cuenta con su propia unidad de procesamiento ALU (unidad aritmético-lógica) y su propio conjunto de registros.\par
                    Cada tarea que ordenamos realizar a nuestro microcontrolador, ocupa uno de sus núcleos por fracciones de segundo hasta acabar con dicha ejecución, sin permitir que otra función ocurra en simultáneo.\par
                    Aún administrando de forma inteligente el modo en el que nuestro microcontrolador ejecuta todas sus tareas, seguimos encontrándonos con una problemática a la hora de intentar ejecutar varias funciones a la vez.\par
                    En nuestro sistema utilizamos un Encoder, componente que entrega datos de forma constante a través de sus dos terminales de salida. Constantemente debemos leer los pulsos que envía y procesarlos, para asegurar que la lectura sea correcta.\par 
	                Uno de los núcleos del microcontrolador (core\_0) se encuentra constantemente ejecutando las tareas de FreeRTOS, mientras que al 2do núcleo (core\_1) le asignamos una única tarea, la lectura del encoder.
                    Para poder utilizar este 2do núcleo, tuvimos que iniciar las funciones del multicore en el main.c.\par
                    \lstinputlisting[language=C, firstline=25, lastline=25]{maino.c}\par
	                Donde iniciamos el multicore solicitando la ejecución de la tarea core\_1\_task en nuestro caso. Esta tarea, nuevamente está conformada por un bucle infinito, y tiene como único objetivo la lectura y procesamiento de datos del Encoder.\par
	                Teniendo en cuenta que cada núcleo cuenta con su propio conjunto de registros, al querer solicitar datos del núcleo sobre el que no estamos trabajando, nos encontramos con otra problemática.\par
	                FreeRTOS nos otorga una solución, la implementación de colas.\par
                    Al hablar de colas, interviene la elección de un “Método de gestión de cargas”. Se trata de las técnicas utilizadas en estructuras de datos al comenzar a utilizar la teoría de colas. Podemos encontrarnos con dos tipos de colas; estas difieren entre sí por el orden de llegada de datos, y su posterior orden de lectura:\par
                    \begin{itemize} [label=•]
                        \setlength{\itemindent}{1.5em}
                        \item FIFO (First-In, First-Out): Son colas cuyos valores de entrada son procesados en el mismo orden en el que fueron agregados.
                        \item LIFO (Last-In, First-Out). Son colas cuyo comportamiento responde a la lógica del “último elemento que ingresa es el primero en salir”.
                    \end{itemize}

                    \begin{figure}[H]
                        \centering
                        \includegraphics[width=0.5\linewidth]{Software/FIFO.png}
                        \caption{Cómo funciona FIFO y LIFO}
                        \label{fig:s1}
                    \end{figure}

                    En  nuestro programa, utilizamos colas FIFO para interconectar ambos núcleos, declarando un acceso directo a la entrada de la cola desde el \texttt{core\_0}, por ejemplo, en conjunto con otro acceso a la salida de dicha cola en el \texttt{core\_1}. No hay superposición entre los registros de ambos núcleos, por lo tanto puede funcionar de forma correcta.\par
	                Las colas FIFO las podemos utilizar desde nuestro programa aprovechando las funciones:\par
                    \texttt{void multicore\_fifo\_push\_blocking(uint32\_t data);}\par
                    Esta función es la que agrega un parámetro de formato (uint32\_t data) a la cola.\par
                    \texttt{uint32\_t multicore\_fifo\_pop\_blocking();}\par
                    Esta función es la que luego lo recogerá, para almacenarlo en una variable del mismo tipo.\par

%// void multicore_fifo_push_blocking(uint32_t data);
	%Esta función es la que agrega un parámetro de formato (uint32_t data) a la cola.
%// uint32_t multicore_fifo_pop_blocking();
%Esta función es la que luego lo recogerá, para almacenarlo en una variable del mismo tipo.

                %\subsubsection{Core0}
                    %Este núcleo trabaja con el sistema en tiempo real FreeRTOS, un sistema basado en tareas y en la interrupción/continuación de las mismas para asegurar un empleo óptimo de los recursos del microcontrolador.\par
                    %Cada tarea cuenta con un nivel de importancia o \textbf{prioridad}.\par
                    
                %\subsubsection{Core1}
                    %Este segundo núcleo es el encargado de recibir los datos del Encoder. Al tratarse de un componente que (durante la carga o descarga del motor) envía pulsos que habrá que leer y procesar en tiempo real, debimos administrar su lectura por separado.\par
                
        \section{Desarrollo del Servidor Web}
            
            \subsection{Módulo ESP8266-01}
                Se trata de un módulo wifi de la familia ESP, se encarga de generar un servidor web, mismo del que la aplicación móvil luego obtendrá los datos para el usuario.\par
                Para más información sobre este componente en concreto revisar el Apéndice C, y más específicamente la Figura \ref{esp8266}\par
            
            \subsection{Lógica}
                El sistema de control envía los datos recogidos cada una cierta cantidad de tiempo por medio de un canal de comunicación tipo UART a la ESP8266.\par